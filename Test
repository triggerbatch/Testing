def serialize_tools(self, tools):
    """
    Convert MCP tools to Azure OpenAI function calling format.
    
    MCP format -> OpenAI format:
    {
        "type": "function",
        "function": {
            "name": "tool_name",
            "description": "tool description",
            "parameters": {
                "type": "object",
                "properties": {...},
                "required": [...]
            }
        }
    }
    """
    serialized = []
    
    for tool in tools:
        properties = {}
        required = []
        
        # Extract properties from MCP tool inputSchema
        input_schema = tool.inputSchema if hasattr(tool, 'inputSchema') else {}
        
        # Handle $defs case (JSON Schema references)
        if '$defs' in input_schema:
            for key, value in input_schema.get('properties', {}).items():
                if '$ref' in value:
                    # Resolve reference
                    ref_key = value['$ref'].split('/')[-1]
                    if ref_key in input_schema['$defs']:
                        ref_schema = input_schema['$defs'][ref_key]
                        properties[key] = {
                            "type": ref_schema.get('type', 'string'),
                            "description": value.get('description') or ref_schema.get('description') or key
                        }
                else:
                    properties[key] = {
                        "type": value.get('type', 'string'),
                        "description": value.get('description') or key
                    }
        else:
            # Direct properties without references
            for key, value in input_schema.get('properties', {}).items():
                properties[key] = {
                    "type": value.get('type', 'string'),
                    "description": value.get('description') or key
                }
        
        # Get required fields
        required = input_schema.get('required', [])
        
        # Build OpenAI function calling format
        serialized_tool = {
            "type": "function",
            "function": {
                "name": tool.name if hasattr(tool, 'name') else "unknown_tool",
                "description": tool.description if hasattr(tool, 'description') else f"Tool: {tool.name}",
                "parameters": {
                    "type": "object",
                    "properties": properties,
                    "required": required
                }
            }
        }
        
        serialized.append(serialized_tool)
    
    return serialized

async def get_all_tools(self):
    """
    Combine local actions with MCP tools
    """
    all_tools = []
    
    # 1. Get local actions (existing Nexus actions)
    if self.actions:
        all_tools.extend(self.actions)
    
    # 2. Get MCP tools from connected servers
    if self.mcp_servers:
        for mcp_server in self.mcp_servers:
            mcp_tools = await self.fetch_mcp_tools(mcp_server)
            all_tools.extend(mcp_tools)
    
    return all_tools

async def run_tool(self, function_name, function_args):
    """
    Check if tool is local or MCP and execute accordingly
    """
    # Check if it's a local action
    if function_name in self.local_actions:
        return self.local_actions[function_name](**function_args)
    
    # Otherwise, execute via MCP
    return await self.mcp_client.call_tool(function_name, function_args)



async def get_response_stream(self, user_input, thread_id=None):
    self.last_message = ""
    self.messages += [{"role": "user", "content": user_input}]
    
    # Step 1: Connect to MCP server and get tools
    self.tools = await self.get_tools()  # Returns MCP tools
    
    # Step 2: Convert MCP tools to OpenAI format
    if self.tools and len(self.tools) > 0:
        tools_serializable = self.serialize_tools(self.tools)
        print(json.dumps(tools_serializable, indent=4))
        
        # Step 3: Send to Azure OpenAI with converted tools
        response = self.client.chat.completions.create(
            model=self.model,
            messages=self.messages,
            temperature=self.temperature,
            tools=tools_serializable,  # OpenAI format
            tool_choice="auto"
        )
        
        response_message = response.choices[0].message
        tool_calls = response_message.tool_calls
        
        # Step 4: If model wants to call tools
        if tool_calls:
            self.messages.append(response_message)
            
            # Step 5: Execute each tool via MCP
            for tool_call in tool_calls:
                function_name = tool_call.function.name
                function_args = json.loads(tool_call.function.arguments)
                print(f"Calling MCP tool: {function_name} with args: {function_args}")
                
                # Execute via MCP
                function_response = await self.run_tool(function_name, function_args)
                
                # Add tool result to messages
                self.messages.append({
                    "role": "tool",
                    "tool_call_id": tool_call.id,
                    "name": function_name,
                    "content": str(function_response)
                })
            
            # Step 6: Get final response from model
            final_response = self.client.chat.completions.create(
                model=self.model,
                messages=self.messages,
                temperature=self.temperature
            )
            
            return final_response.choices[0].message.content



